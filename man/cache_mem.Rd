% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cache-memory.R
\name{cache_mem}
\alias{cache_mem}
\title{Create a memory cache object}
\usage{
cache_mem(
  max_size = 100 * 1024^2,
  max_age = Inf,
  max_n = Inf,
  evict = c("lru", "fifo"),
  missing = key_missing(),
  exec_missing = FALSE,
  logfile = NULL
)
}
\arguments{
\item{max_size}{Maximum size of the cache, in bytes. If the cache exceeds
this size, cached objects will be removed according to the value of the
`evict`. Use `Inf` for no size limit.}

\item{max_age}{Maximum age of files in cache before they are evicted, in
seconds. Use `Inf` for no age limit.}

\item{max_n}{Maximum number of objects in the cache. If the number of objects
exceeds this value, then cached objects will be removed according to the
value of `evict`. Use `Inf` for no limit of number of items.}

\item{evict}{The eviction policy to use to decide which objects are removed
when a cache pruning occurs. Currently, `"lru"` and `"fifo"` are supported.}

\item{missing}{A value to return or a function to execute when `get(key)` is
called but the key is not present in the cache. The default is a
[key_missing()] object. If it is a function to execute, the function must
take one argument (the key), and you must also use `exec_missing = TRUE`.
If it is a function, it is useful in most cases for it to throw an error,
although another option is to return a value. If a value is returned, that
value will in turn be returned by `get()`. See section Missing keys for
more information.}

\item{exec_missing}{If `FALSE` (the default), then treat `missing` as a value
to return when `get()` results in a cache miss. If `TRUE`, treat `missing`
as a function to execute when `get()` results in a cache miss.}

\item{logfile}{An optional filename or connection object to where logging
information will be written. To log to the console, use `stderr()` or
`stdout()`.}
}
\description{
A memory cache object is a key-value store that saves the values in an
environment. Objects can be stored and retrieved using the `get()` and
`set()` methods. Objects are automatically pruned from the cache according to
the parameters `max_size`, `max_age`, `max_n`, and `evict`.
}
\details{
In a `cache_mem`, R objects are stored directly in the cache; they are not
*not* serialized before being stored in the cache. This contrasts with other
cache types, like [cache_disk()], where objects are serialized, and the
serialized object is cached. This can result in some differences of behavior.
For example, as long as an object is stored in a cache_mem, it will not be
garbage collected.
}
\section{Missing keys}{


  The `missing` and `exec_missing` parameters controls what happens when
  `get()` is called with a key that is not in the cache (a cache miss). The
  default behavior is to return a [key_missing()] object. This is a *sentinel
  value* that indicates that the key was not present in the cache. You can
  test if the returned value represents a missing key by using the
  [is.key_missing()] function. You can also have `get()` return a different
  sentinel value, like `NULL`. If you want to throw an error on a cache miss,
  you can do so by providing a function for `missing` that takes one
  argument, the key, and also use `exec_missing=TRUE`.

  When the cache is created, you can supply a value for `missing`, which sets
  the default value to be returned for missing values. It can also be
  overridden when `get()` is called, by supplying a `missing` argument. For
  example, if you use `cache$get("mykey", missing = NULL)`, it will return
  `NULL` if the key is not in the cache.

  If your cache is configured so that `get()` returns a sentinel value to
  represent a cache miss, then `set` will also not allow you to store the
  sentinel value in the cache. It will throw an error if you attempt to do
  so.

  Instead of returning the same sentinel value each time there is cache miss,
  the cache can execute a function each time `get()` encounters missing key.
  If the function returns a value, then `get()` will in turn return that
  value. However, a more common use is for the function to throw an error. If
  an error is thrown, then `get()` will not return a value.

  To do this, pass a one-argument function to `missing`, and use
  `exec_missing=TRUE`. For example, if you want to throw an error that prints
  the missing key, you could do this:

  \preformatted{
  cache_mem(
    missing = function(key) {
      stop("Attempted to get missing key: ", key)
    },
    exec_missing = TRUE
  )
  }

  If you use this, the code that calls `get()` should be wrapped with
  [tryCatch()] to gracefully handle missing keys.

  @section Cache pruning:

  Cache pruning occurs when `set()` is called, or it can be invoked manually
  by calling `prune()`.

  When a pruning occurs, if there are any objects that are older than
  `max_age`, they will be removed.

  The `max_size` and `max_n` parameters are applied to the cache as a whole,
  in contrast to `max_age`, which is applied to each object individually.

  If the number of objects in the cache exceeds `max_n`, then objects will be
  removed from the cache according to the eviction policy, which is set with
  the `evict` parameter. Objects will be removed so that the number of items
  is `max_n`.

  If the size of the objects in the cache exceeds `max_size`, then objects
  will be removed from the cache. Objects will be removed from the cache so
  that the total size remains under `max_size`. Note that the size is
  calculated using the size of the files, not the size of disk space used by
  the files --- these two values can differ because of files are stored in
  blocks on disk. For example, if the block size is 4096 bytes, then a file
  that is one byte in size will take 4096 bytes on disk.

  Another time that objects can be removed from the cache is when `get()` is
  called. If the target object is older than `max_age`, it will be removed
  and the cache will report it as a missing value.
}

\section{Eviction policies}{


If `max_n` or `max_size` are used, then objects will be removed
from the cache according to an eviction policy. The available eviction
policies are:

  \describe{
    \item{`"lru"`}{
      Least Recently Used. The least recently used objects will be removed.
      This uses the filesystem's atime property. Some filesystems do not
      support atime, or have a very low atime resolution. The cache_mem will
      check for atime support, and if the filesystem does not support atime,
      a warning will be issued and the "fifo" policy will be used instead.
    }
    \item{`"fifo"`}{
      First-in-first-out. The oldest objects will be removed.
    }
  }
}

\section{Methods}{


 A disk cache object has the following methods:

  \describe{
    \item{`get(key, missing, exec_missing)`}{
      Returns the value associated with `key`. If the key is not in the
      cache, then it returns the value specified by `missing` or,
      `missing` is a function and `exec_missing=TRUE`, then
      executes `missing`. The function can throw an error or return the
      value. If either of these parameters are specified here, then they
      will override the defaults that were set when the cache_mem object was
      created. See section Missing Keys for more information.
    }
    \item{`set(key, value)`}{
      Stores the `key`-`value` pair in the cache.
    }
    \item{`exists(key)`}{
      Returns `TRUE` if the cache contains the key, otherwise
      `FALSE`.
    }
    \item{`size()`}{
      Returns the number of items currently in the cache.
    }
    \item{`keys()`}{
      Returns a character vector of all keys currently in the cache.
    }
    \item{`reset()`}{
      Clears all objects from the cache.
    }
    \item{`destroy()`}{
      Clears all objects in the cache, and removes the cache directory from
      disk.
    }
    \item{`prune()`}{
      Prunes the cache, using the parameters specified by `max_size`,
      `max_age`, `max_n`, and `evict`.
    }
  }
}

